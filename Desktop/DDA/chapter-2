Chapter 2 -  Data Models and Query Languages 

- Data models have a profound effect in not only how the software is written but also on how we think about the problem that we are solving. 
- Most applications are built by layering one data model on top of another - for each layer the key question is: how is it represented in terms of the next-lower layer? For example: as an application developer, you look at the real world (in which there are people, organizations, goods, actions, money flows, sensors) and model it in terms of object or data structures and APIs that manipulate those data structures. Those data structures are often specific to your application; when you want to store those data structures, you express them in terms of a general-purpose data model, such as JSON and XML documents, tables in relational databases or a graph model; the engineers who built your database software decided on a way of representing that JSON/XML/relational/graph data in terms of bytes in memory, on disk or on a network. The representation may allow the data to be queried, searched, manipulated and processed in various ways; on set lower level, hardware engineers have figured out how to represent bytes in terms of electrical currents, pulses of lights, magnetic fields and more. 
- There are many different kinds of data models and every data model embodies assumptions about how it is going to be used. Some kinds of usage are easy and some are not supported; some operations are fast and some perform badly; some data transformations feel natural and some are awkward. It can take a lot of effort to master just one data model but since the data model has such a profound effect on what software above it can or can’t do it is important to choose one that is appropriate to the application. 
- Relational Model Versus Document Model - the best known data model today is probably SQL based on the relational model proposed - data is organized into relations (tables in SQL), where each relation is unordered collections of tuples (rows). The roots of relational databases lie in business data processing typically transaction processing (entering sales, airline reservations, stock-keeping) and batch processing (payroll, reporting, customer invoicing). Network model and hierarchical model were the main alternatives but relational model came to dominate them. 
- Birth of NoSQL - NoSQL is the latest attempt to overthrow the relational model’s dominance. There are several driving forces behind the adoption of NoSQL databases, including: a need for greater scalability than relational databases can easily achieve, including very large datasets or very high write throughput; a widespread preference for free and open source software over commercial database products; specialized query operations that are not well supported by the relational model; frustration with the restrictiveness of relational schemas, and a desire for a more dynamic and expressive data model. Different applications have different requirements and the best choice of technology for one use case may well be different from the best choice for another use case. It seems likely that in the foreseeable future, relational databases will continue to be used alongside a broad variety of non-relational datastore - an idea that is called polygon persistence. 
- The Object-Relational Mismatch: most applications development today is done in object-oriented programming languages, which leads to a common criticism of the SQL data model: if data is stored in relational tables, an awkward translation layer is required between the objects in the application code and the database model of tables, rows and columns. The disconnect between the models is sometimes called an impedance mismatch. Object-relational mapping ORM frameworks like ActiveRecord and Hibernate reduce the amount of boilerplate code required for this translation layer, but they completely hide the difference between the two models. 
- There is a one-to-many relationship from the user to these items, which can be represented in various ways: in the traditional SQL model prior to 1999, the most common normalized representation is to put positions, education and contact information in separate tables, with a foreign key reference to the users table; later versions of the SQL standard added support for structured datatypes and XML data, this allowed multi-valued data to be stored within a single row with support for the querying and indexing inside those documents; a third option iOS to encode jobs, education and contact info as a JSON and XML document, store it on a text column in the database and let the application interpret its structure and content. In this setup, you typically cannot use the database to query for values inside that encoded column.
- Some developers feel that the JS0N model reduces the impedance mismatch between the application code and the storage layer. However, as we shall see in Chapter 4, there are also problems with JSON as a data encoding format. 
- Revisit 31-32.
- Many-to-One and Many-to-Many Relationships: there are advantages to having standardized lists of geographical regions and industries and letting users choose from a drop-down list or auto-complete bc consistent style and spelling across profiles; avoiding ambiguity (several cities with the same name); ease of updating - the name is stored in only one place so it is easy to update across the board if it ever needs to be changed (change of a city name due to political events); localization support - when the site is translated into other languages, the standardized lists can be localized so the region and industry can be displayed in the viewer’s language; better search - a search for philanthropists in the state of Washington can match this profile because the list of regions can encode the fact that Seattle is in Washington (which is not apparent from the string “Greater Seattle Area”). 
- Whether you store an ID or a text string is a question of duplication - when you use an ID, the information that is meaningful to humans is stored in only one place, and everything that refers to it uses an ID. When you store the text directly, you are duplicating the human-meaningful information to every record that uses it. The advantages of using an ID is that because it has no meaning to humans, it never needs to change: the ID can remain the same even if the information it identifies changes. Anything that is meaningful to humans may need to change, sometime in the future - and if that information is duplicated, all the redundant copies need to be updated. That incurs write overheads, and risk inconsistencies (where some copies of the information are updated but other’s aren’t). Removing such duplication is the key idea behind normalization in databases. 
- Unfortunately, normalizing this data requires many-to-one relationships (many people work in one particular region, many people work in one particular industry), which don’t fit nicely into the document model. In relational databases, it’s normal to refer to rows in other tables by ID, because joins are easy. In document databases, joins are not needed for one-to-many tree structures and support for joins is often weak. If the database itself does not support joins, you have to emulate a join in application code by making multiple queries to the database. 
- Even if the initial version of an application fits well in a join-free document model, data has a tendency of becoming more interconnected as features are added to applications. For example, consider some changes we could make to the resume example: 
	>organizations and schools as entities : in the previous description, organization (the 			company where the user worked) are just strings. Perhaps they should be references to 			entities instead? Then each organization, school or university could have its own web page 		(with logo, news feed and etc); each resume could link to the organizations and schools that it 	mentions, and include their logos and other information.
	>recommendations: say you want to add a new feature: one user can write a recommendation 	for another user. The recommendation is shown on the resume of the user who was 			recommended, together with the name and photo of the user making the recommendation. If 		the recommender updates their photo, any recommendations they have written need to reflect 	the new photo. Therefore, the recommendation should have a reference to the author’s profile. 
- Are Document Databases Repeating History?: while many-to-many relationships and joins are routinely used in relational databases, document databases and NoSQL reopened the debate on how best to represent such relationships in database. The most popular database for business data processing in the 1970s was IBM’s Information Management System (IMS), originally developed for stock-keeping in the Apollo space program and first commercially released in 1968. The design of IMS used a fairly simple data model called the hierarchical model, which has some remarkable similarities to the JSON model used by document databases. It represented all data as tree of records nested within records, much like the JSON structure. Like document databases, IMS worked well for one-to-many relationships, but it made many-many relationships difficult, and it didn’t support joins. Developers had to decide whether to duplicate (denormalize) data or to manually resolve references from one record to another. These problems of the 1960s and 70s were very much like the problems that developers are running into with document databases today. Various solutions were proposed to solve the limitations of the hierarchical model. The two most prominent were the relational model (which became SQL and took over the world) and network model (which initially had a large following but eventually faded into obscurity). 
- The network model: was standardized by a committee is called the Conference on Data System Languages (CODASYL) and implemented by several different databases vendors, it is also know as the CODASYL model. The CODASYL model was a generalization of the hierarchical model. In the tree structure of the hierarchical model, every record has exactly one parent; in the network model, a record could have multiple parents. For example, there could be one record for the “Greater Seattle Area” region and every user who lived in that region could be linked to it. This allows many-to-one and many-to-many relationships to be modeled. The links between records in the network model were not foreign kets, but more like pointers in a programming language (while still being stored on disk). The only way of accessing a record was to follow a path from a root record along these chains of links. This was called an access path. In the simplest case, an access path could be like the traversal of a linked list: start at the head off the list, and look at one record at a time until you find the one you want. But in the world of many-to-many relationships, several different paths can lead to the same record and programmer working with the network model had to keep track of these different access paths in their head. A query in CODASYL was performed by moving a cursor through the database by iterating over lists of records and following access paths. If a record had multiple parents (i.e multiple incoming pointers from other records), the application code had to keep track of all the various relationships. Even CODASYL committee members admitted that this was like navigating around an n-dimensional data space. Although manual access path selection was able to make the most efficient use of the very limited hardware capabilities in the 1970s, the problem was that they made the code for querying and updating the database complicated and inflexible. With both the hierarchical and the network model, if you didn’t have a path to the data you wanted, you were in a difficult situation. You could change the access paths, but then you had to go through a lot of handwritten database query code and rewrite it to handle the new access paths. It was difficult to make changes to an applications data model. 
- The relational model: is made to lay out all the data in the open: a relation (table) is simply a collection of tuples (rows) and that’s it. You can read any or all of the rows in a table, selecting those that match an arbitrary condition. You can read a particular row by designating some columns as a key and matching on those. You can insert a new row into any table without worrying about foreign key relationships to and from other tables. In relational database, the query automatically decides which parts of the query to execute in which order, and which indexes to use. Those choices are effectively the “access path”, but the big difference is that they are made automatically by the query optimizer not by the application developer, so we rarely need to think about them. If you want to query your data in new ways, you can just declare a new index and queries will automatically use which ver indexes are most appropriate. You don’t need to change your queries to take advantage of a new index. The relational model thus made it much easier to add new features to an applications. Query optimizers for relational databases are complicated beasts, and they have consumed many years of research and development effort. But a key insight of the relational model was this: you only need to build a query optimizer once, and then all applications that use the database can benefit from it. If you don’t have a query than to write a general-purpose optimizer - but the general purpose solution wins in the long run. 
- Comparison to document databases: document databases reverted back to the hierarchical model in one aspect: storing nested records (one-to-many relationships, like positions, education and contact_info) within their parent record rather than in a separate table. However, when it comes to representing many-to-one and many-to-many relationships, relational and document databases are not fundamentally different: in both cases, the related item is referenced by a unique identifier which is called a foreign key in a relational model and a document reference in the document model. That identifier is resolved at read time by using a join or follow-up queries. To date, document databases have no followed the path of CODASYL. 
- Relational Versus Document Databases Today: in this chapter we will concentrate only on differences in the data model. The main arguments in favor of the document data model are schema flexibility, better performance due to locality and that for some applications it is closer to the data structures used by the application. The relational model counters by providing better support for joins, and many-to-one and many-to-many relationships.
- Which data model leads to simpler application code ?: if the data in your application has a document-like structure (a tree of one-to-many relationships, where typically the entire tree is loaded at once), then its probably a good idea to use a document model. The relational technique of shredding - uplifting a document-like structure into multiple tables (like positions, education and contact_info) can lead to cumbersome schemas and unnecessarily complicated application code. The document model has limitations: foe example, you cannot refer directly to a nested item within a document, but instead you need to say something like “the second item in the list of positions for user 251” (much like an access path in the hierarchical model). However, as long as documents are not too deeply nested that is not usually a problem. The poor support for joins in document databases may or may not be a problem, depending on the application. For example, many-to-many relationships may never be needed in an analytics application that uses a document database to record which events occurred at which time. However, if your application does use many-to-many relationships, the document model becomes less appealing. It’s possible to reduce the need for joins by denormalizing, but then the application code needs to do additional work to keep the denormalized data consistent. Joins can be emulated in application code by making, multiple requests to the database, but that also moves complexity into the application and is usually slower than a join performed by specialized code inside the database. In such cases, using a document model can lead to significantly more complex application code and worse performance. It’s not possible to say in general which data model leads to simpler application code; it depends on the kinds of relationships that exist between data items. For highly, interconnected data, the document model is awkward, the relational model is acceptable and graph models are the most natural. 
- Schema flexibility in the document model : most document databases, and the JSON support in relational databases, do not enforce any schema on the data in documents. XML support in relational databases usually comes with optional schema validation. No schema means that arbitrary keys and values can be added to a documents, and when reading, client have no guarantees as to what fields the documents may contain. Document databases are sometimes called schemaless, but that’s misleading as the code that reads the data usually assume some kind of structure. A more accurate term is schema-on-read (the structure of the data is implicit, and only interpreted when the data is read), in contract with schema-on-write (the traditional approach of relational databases, where the schema is explicit and the database ensures all written data conforms to it). Schema-on-read is similar to dynamic (runtime) type checking in programming languages, whereas schema-on-write is similar to static (compile-time) type checking. Schemas changes have a bad reputation of being slow and requiring downtime. This reputation is not entirely deserved: most relational database systems execute the ALTER TABLE statement in a few milliseconds. MySQL is a notable exception - it copies the entire table on ALTER TABLE, which can mean minutes or even hours of downtime when altering a large table - although various tools work around this limitation. Running the UPDATE statement on a large table is likely to be slow on any database since every row needs to be rewritten. If that is not acceptable, the application can leave first_name set to its default to NULL and fill it in at read time, like it would with a document database.
- The schema-on-read approach is advantageous if the items in the collection don’t all have the same structure for some reason (data is heterogeneous), for example because:
	> the are many different types of objects, and it is not practical to put each type of object in 		its own table.
	> the structure of the data is determined by external systems over which you have no control 
	and which may change at any time.
	- in situations like these, a schema may hurt more than it helpers and cheerless documents 		can be much more natural data model. But in cases where all records are expected to have 		the 	same structure, schemas are a useful mechanism for documenting and enforcing that 		structure. 
- Data locality for queries: a documents is usually stored as single continuous string, encoded as JSON, XML, or a binary variant thereof. If you application often needs to access the entire document (to render a webpage), there is a performance advantage to this storage locality. If the data is split across multiple tables, multiple index lookups are required to retrieve it all, which may require more disk seeks and take more time. The locality advantage only applies if you need large parts of the document at the same time. The database typically needs to load the entire document, even if you need to access only a small portion of its, which can be wasteful on large documents. On updates to a document, the entire document usually needs to be rewritten - only modifications that don’t change the encoded size of a document can easily be formed in place. For the reasons, it is generally recommended that you keep documents fairly small and avoid write that increase the size of a document. These performance limitations significantly reduce the set of situation in which document databases are useful. It is worth pointing out that the idea of grouping related data together for locality is not limited to the document model. For example, Google’s Spanner databases offers the same locality that a table’s row should be interleaved within a parent table. 
- Convergence of document and relational databases: most relational database systems (other than MySQL) have supported XML since the mid-2000s. This includes functions to make local modifications to XML documents and the ability to index and query inside XML documents, which allows applications to use data models very similar to what they would do when using a document database. PostgresSQL since version 9.3, MySQL since version 5.7 and IBM DB2 since version 10.5 also ave similar levels of support for JSON documents. Given the popularity of JSOn for web APIs, it is likely that other relational databases will follow in their footsteps and add JSON support. On the document database side, RethinkDB supports relational-like join in its query language and some MongoDB drivers automatically resolve database reference. It seems that relational and document databases are becoming more similar over time, and that is a good thing: data models complement each other. If a database is able to handle document-like data and also perform relational queries on it, application can use the combination of features that best fits their needs. A hybrid of the relational and document models is a good route for databases to take in the future. 
- Query Languages for Data:  when the relational model was introduced, it included a new way of querying data SQL is a declarative query languages are imperative. What does this mean? Many commonly used programming languages are imperative. An imperative language tells the computer to perform certain operations in a certain order. You can imagine stepping through the code line by line, evaluating conditions, updating variables and deciding whether to go around the loop one more time. In a declarative query language, like SQL or relational algebra, you just specify the pattern of the data you want - what conditions the results must meet and how you want the data to be transformed (sorted, grouped, aggregated) - but now how to achieve that goal. It is up to the database system’s query optimizer to decide which indexes and which join methods to use and in which order to execute various parts of the query. A declarative query language is attractive because it typically more concise and easier to work with than an imperative API. But more importantly, it also hides implementation details of the databases engine which makes it possible for the database system to introduce performance improvements without requiring any changes to the queries. If the database wants to reclaim unused disk space behind the scenes, it might need to move records around, changing the order in which the animals appear. Can the database do that safely, without breaking queries? The SQL example doesn’t guarantee any particular ordering, and so it doesn’t mind if the order changes. But if the query is written as imperative code, the database can never be sure whether the code is relying on the ordering or not. The fact that SQL is more limited in functionality gives the database much more room for automatic optimizations. Finally, declarative languages often lend themselves to parallel execution. Today CPU are getting faster by adding cores. Imperative code is very hard to parallelize across multiple cores and multiple machines because it specifies instructions that must be performed in a particular order. Declarative languages have a better chance of getting faster in parallel execution because they specify only the pattern of the results not the algorithm that is used to determine the results. The database is free to use a parallel implementations of the query language, if appropriate. 
- Declarative Queries on the Web: what CSS and XSL have in common is that they are both declarative languages for specifying the styling of a document. If the selected class is removed (bc the user clicks a different page), the blue color won’t be removed, even if the code is rerun - and so the item will remain highlighted until the entire page is reloaded. With CSS, the browser automatically detects when the li.selected > p rule no longer applies and removes the blue background as soon as the selected class is removed. If you want to take advantage of a new API, such as document.getElementsByClassName(“selected”) or even document.evaluate()- which may improve performance - you have to rewrite the code. On the other hand, browser vendors can improve the performance of CSS and XPath without breaking compatibility. In web browser, using declarative CSS styling is much better than manipulating styles imperatively in JS. Similarly, in databases, declarative query languages like SQL turned out to be much better than imperative query APIs. 
- MapReduce Query - MapReduce is a programming model for processing large amounts of data in bulk across many machines, popularized by Google. A limited form of MapReduce is supported by some NoSQL datastore, including MongoDB and CouchDB, a mechanism for performing read-only queries across many documents. MapReduce is neither a declarative query language nor a fully imperative query API but somehow in between: the logic of the query is expressed with snippets of code, which are called repeatedly by the processing framework. It is based on the map and reduce functions in many functional programming languages. The map and reduce functions are somewhat restricted in what they are allowed to do. They must be pure functions, which means they only use the data that is passed to them as input, they cannot perform additional database queries, and they must not have any side effects. These restrictions allow the database to run the functions anywhere, in any order, and rerun them on failure. However, they are nevertheless powerful: they can parse strings, call library functions, perform calculations and more. MapReduce is a fairly low level programming model for distributed execution on a cluster of machines. Higher-level query languages like SQL can be implemented as a pipelines of MapReduce operations but there are also many distributed implementations of SQL that don’t use MapReduce. Note that there is nothing in SQL that constraints it to running on a single machine and MapReduce doesn’t have a monopoly on distributed query execution. Being able to use JS code in the middle of a query is a great feature for advanced queries but its not limited to MapReduce - some SQL db can be extended with JS functions too. A usability problem with MapReduce is that you have to write two carefully coordinated JS functions which is often harder than writing a single query. Moreover, a declarative query language offers more opportunities for a query optimizer to improve the performance of a query. For these reasons, MongoDB 2.2 added support for declarative query language called aggregation pipeline. The aggregation pipeline language is similar in expressiveness to a subset of SQL, but it uses a JSON-baed syntax rather than SQL’s English-sentence-style syntax; the difference is a matter of taste. The moral of the story is that a NoSQL system may find itself accidentally being SQL, albeit in disgust. 
- Graph-Like Data Models: we saw earlier that many-to-many relationships are an importantly distinguishing feature between different data models. If your application has mostly one-to-many relationships (tree-structured data) or no relationships between records, the document model is appropriate. But what if many-to-many relationships are very common in your data? The relational model can handle simple cases of many-to-many relationships, but as the connections within your data become more complex, it becomes more natural to start modeling your data as a graph. A graph consists of two kinds of objects: vertices aka nodes/entities and edges aka relationships/arcs. Many kinds of data can be modeled as a graph: 
	> social graph: vertices are people, and edges indicate which people know each other. 
	> the web graph: vertices are web pages, and edges indicate HTML links to other pages. 
	> road or rail networks: vertices are junctions and edges represent the roads or railways lines between them. 
- Well known algorithms can operate on these graphs such as car navigation systems search for the shortest path between two points in a road network and PageRank can be used on the web graph to determine the popularity of a web page and thus its ranking in search results. All the vertices in a graph represent the same kind of thing. However, graphs are not limited to such homogeneous data: an equally powerful use of graphs is to provide a consistent way of storing completely different types of objects in a single datastore. For example, Facebook maintains a single graph with many different types of vertices and edges, vertices represent people, locations, events checkins and comments made by users; edges indicate which people are friends with each other, which checkin happened in which location, who commented on which post and so on. 
- There are several different, but related, ways of structuring and querying data in graphs. In this section we discuss property graph model (implemented by Neo4j, Titan and InfiniteGraph) and triple-store model (implemented by Datomic, AllgeroGraph and others). We will look at three declarative query languages for graphs: Cypher, SPARQL, and Datalog. Beside these there are imperative graph query languages such as Gremlin and graph processing framework like Pregel. 
- Property Graphs: in the property graph model, each vertex consists of a unique identifier, a set of outgoing edges, a set of incoming edges, a collection of properties (k-v pairs) and each edge consists of a unique identifier, the vertex at which the edge starts (tail), the vertex at which the edge ends (head), a label to describe the kind of relationship between the two vertices and a collection of properties (k-v) pairs. You can think of a graph store as consisting of two relational tables, one for vertices and one for edges. The head and tail vertex are stored for each edge; if you want the set of incoming or outgoing edges for a vertex, you can query the edges table by head_vertex or tail_vertex, respectively. 
- Some important aspects of this model are: 
	> any vertex can have an edge connecting it with any other vertex. There is no schema that restricts which kinds of things can or cannot be associated. 
	> given any vertex, you can efficiently find both its incoming and its outgoing edges and thus traverse the graph - follow a path through a chain of vertices - both forward and backward. 
	> by using different labels for different kinds of relationships, you can store several different kinds of information in a single graph, while maintaining a clean data model. 
- Those features give graphs a great deal of flexibility for data modeling. A few things would be difficult to express in a traditional relational schema, such as different kinds of regional structures in different countries, quirks of history such as a country within a country and varying granularity of data. You could imagine extending the graph to also include many other facts about Lucy and Alain, or other people. For instance, you could use it to indicate any food allergies they have (by introducing a vertex for each allergen, and an edge between a person and an allergen to indicate an allergy), and link the allergens with a set of vertices that show which food contain which substances. Then you could write a query to find out what is safe for each person to eat. Graphs are good for evolvability: as you add features to your application, a graph can easily be extended to accommodate changes in your application’s data structures. 
- The Cypher Query Language: a cypher is a declarative query language for property graphs, created for the Neo4j graph database. Example 2-4; there are several possible ways of executing the query. The description given here suggests that you start by scanning all the people in the database, examine each person’s birthplace and residence, and return only those people who meet the criteria. But equivalently, you could start with the two Location vertices and worked backward. If there is an index on the name property, you can probably efficiently find the two vertices representing the US and Europe. Then you can proceed to find all locations in the US and Europe respectively by following all incoming WITHIN edges. Finally, you can look for people who can be found through an incoming BORN_IN or LIVES_IN edge at one of the locations vertices. As is typical for a declarative query language, you don’t need to specify such execution details when writing the query: the query optimizer automatically chooses a strategy that is predicted to be the most efficient, so you can get on with writing the rest of your application. 
- Graph Queries in SQL: graph data can be represented in a relational database. But if we put graph data in a relational structure, can we also query it using SQL? The answer is yes, but with some difficulty. In a relational db, you usually know in advance which joins you need in your query. In a graph query, you may need to traverse a variable number of edges before you can find the vertex you’re looking for - that is, the number of joins is not fixed in advance. If the same query can be written in four lines in one query language but requires 29 lines in another, that just shows that different data models are designed to satisfy different use cases. Its important to pick a data model that is suitable for your application.
- Triple-Stores and SPARQL: the triple-store model is mostly equivalent to the property graph model, using different words to describe the same ideas. It is nevertheless worth discussing, because there are various tools and languages for triple-stores that can be valuable additions to your toolbox for building apps. In a triple-store, all info is stores in the form of very simple three-part statements: (subjects, predicate, object). The subject of a triple is equivalent to a vertex in a graph. The object is one of two things: 
	>a value in primitive datatype, such as a string or a number. In that case, the predicate and object of the triple are equivalent to the key and value of a property on the subject vertex. For example, (Lucy, age, 33) is like a vertex Lucy with properties {“age” :33}
	>another vertex in the graph. In that case, the predicate is an edge in the graph, the subject is the tail vertex, and the object is the head vertex. For example (Lucy, marriedTo, Alain)the subject and object Lucy and Alain are both vertices, and the predicate marriedTo is the label of the edge 	that connects them.
- Its quite repetitive to repeat the same subject over and over again but fortunately you can use semicolons to say multiple things about the same subject.
- The semantic web is fundamentally a simple and reasonable idea websites already publish information as text and pictures for humans to read, so why don’t they also publish information as machine-readable data for computers thread? The Resource Description Framework (RDF) [41] was intended as a mechanism for different websites to publish data in a consistent format, allowing data from different websites to be automatically combined into a web of data - a kind of internet-wide “database of everything”. Unfortunately, the semantic web was overhyped in the early 2000s but so far hasn’t shown any signs of being realized in practice, which has made many people cynical about it. It has also suffered from a dizzying plethora of acronyms, overly complex standards proposals and hubris. However, if you look past those failures there is also a lot of good work that has come out of the semantic web project. Triple can be a good internal data model for applications, even if you have no interest in publishing ref data on the semantic web. 
- RDF Data Modal: RDF has a few quirks due to the fact it is designed for internet-wide data exchange. The subject, predicate and object of a triple are often URIs.
